<p>React Hooks are a very powerful feature (in functional components) - you can learn more about them in my "React -&nbsp;The Complete Guide"&nbsp;course or in the official docs:&nbsp;<a href="https://reactjs.org/docs/hooks-intro.html" rel="noopener noreferrer" target="_blank">https://reactjs.org/docs/hooks-intro.html</a></p><p>One particularly nice feature is that you can build your own React hooks&nbsp;(<a href="https://reactjs.org/docs/hooks-custom.html" rel="noopener noreferrer" target="_blank">https://reactjs.org/docs/hooks-custom.html</a>).</p><p>This allows you to encapsulate and share stateful component logic.</p><p>You can build a hook that uses other built-in hooks (like <code>useState()</code>) and any component that uses your hook will then use the built-in hooks you might be using in your custom hook as well.</p><p>This allows you to build hooks like the <code>useForm()</code>&nbsp;hook we started to build in the previous lecture. The idea here is that we can share our stateful form logic (that uses <code>useReducer()</code>&nbsp;in our case)&nbsp;across components. This avoids code duplication, makes it easy to change the code and leads to more readable code.</p><p>With all that "custom hook"&nbsp;jargon, it's easy to overlook that custom hooks in the end are normal JavaScript functions though - <strong>never forget that!</strong></p><p>If you use <code>useForm()</code> in your component function, it will get called for every re-evaluation of your component (i.e. for every re-render cycle). Hence all the logic in a custom hook runs every time your component function is executed.</p><p>Of course a lot of built-in hooks like <code>useState()</code>&nbsp;or <code>useReducer()</code>&nbsp;have mechanisms to ensure that state changes are kept across re-render cycles.</p>